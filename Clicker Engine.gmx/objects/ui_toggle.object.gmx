<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_ui</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>ui_defaults</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
Copyright (c) 2016 NailBuster Software Inc. (david@nailbuster.com). All rights reserved.



This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.
You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA


*/

event_inherited();
uiDrawBackColor=true;
uiBackColor=c_silver;
uiToggleOn=true;


uiValue=100;  //for toggle you don't use this,  check/set uiToggleOn=true/false
uiToggleOn=true;
uiBarColor=c_blue;
uiBarColorBlend=c_navy;


uiDrawSquare=false; //rounded or rectange;
uiAniDraw=true; //animate the movement....not jump to position
uiAniSpeed=10;   //step added to value.
uiBarSprite=noone;
uiBackSprite=noone;
uiSpriteScale = 1.0;


uiSetValue=-1;  //read only for toggle...do not use, check uiToggleOn for true/false;

curValueMove=0;  //used to set the movement in change....
curValue=-1;      //used to set movement
curAniCounter=0;

uiSlideSprite = -1;       //sprite must have center as origin.
uiSliderColor = c_white;  //if not using a sprite
uiSlideBarHeight= -1;    //use the entire sprite_height or specify

uiOnLabel="ON";
uiOnLabelColor=c_yellow;
uiOffLabel="OFF";
uiOffLabelColor=c_dkgray;
uiOffAlpha=0.8;
uiOutlineWidth = 1;
uiSliderWidth = -1;
uiSpriteAlign = true;
scr_gui_setdefaults();         //you should set your default properties in this script.












</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (uiMouseHandle==false) || (uiEnabled==false) || (uiVisible==false) exit;


event_inherited();



if (uiToggleOn) uiToggleOn=false; 
  else uiToggleOn=true;

if uiEventObject != noone
 if object_exists(uiEventObject) then      //we call the statechanged event on controller if set
   with (uiEventObject) {event_user(0);}

soundindex=1; //click
event_user(10); //process sound event;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
Copyright (c) 2016 NailBuster Software Inc. (david@nailbuster.com). All rights reserved.



This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.
This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.
You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA


*/

var ymargin,disptx,px,curPercent,barWidth,flashDraw,curColor,curBlendColor,ch,cw,tw,barx,bary,barw,barh,xratio,yratio,sw,ow;

event_inherited();
if (uiZoomFactor==0.1) || (uiVisible==false) exit;  //for zooming   


curZoomFactor=uiZoomFactor+uiAniPulse;
curAlpha=uiAlpha-uiAniFading;
curRot=uiAngle+uiAniWobble;

curXscale=uiXscale+uiAniPulse;
curYscale=uiYscale+uiAniPulse;  

disptx=uiTextValue;

draw_set_font(uiFont);
draw_set_halign(uiAlign);
draw_set_valign(fa_top);

if uiDrawSquare {uiRadiusX=0;uiRadiusY=0;}

ow = uiOutlineWidth;
barx=x;
bary=y;
barw=sprite_width;
barh=sprite_height;



if (uiSlideBarHeight&gt;0) //custom bar height
  {
     bary = y+ ((sprite_height - uiSlideBarHeight) div 2);
     barh = uiSlideBarHeight;
  }


if (uiToggleOn==false) draw_set_alpha(uiOffAlpha);

if uiBackSprite != noone  //if we are using a background sprite behind/around the gauge, we use bounding box to get gauge location/size
  {
   if uiSpriteScale==0 {   xratio=sprite_width/sprite_get_width(uiBackSprite);
                           yratio=sprite_height/sprite_get_height(uiBackSprite);
                       } else
                       {   xratio=uiSpriteScale;
                           yratio=uiSpriteScale;
                       }         
    barx=(sprite_get_bbox_left(uiBackSprite)*xratio);
    bary=(sprite_get_bbox_top(uiBackSprite)*yratio);
    barw=(sprite_get_bbox_right(uiBackSprite)*xratio)-barx;
    barh=(sprite_get_bbox_bottom(uiBackSprite)*yratio)-bary;    
    barr=(sprite_get_bbox_bottom(uiBackSprite)-sprite_get_bbox_top(uiBackSprite));  //original bar height
    barx+=x;
    bary+=y;
  } 
  
if uiDrawBackColor 
   {
    if (ow&gt;0) draw_roundrect_color_ext(barx-ow, bary-ow, barx+barw+ow, bary+barh+ow, uiRadiusX,uiRadiusY,uiBorderColor,uiBorderColor, false);   //fill         
    draw_roundrect_color_ext(barx, bary, barx+barw, bary+barh, uiRadiusX,uiRadiusY,uiBackColor,uiBackColor,false);   //fill
   } 

if (uiToggleOn &amp;&amp; uiValue==0) uiSetValue=100;
else if (uiToggleOn==false &amp;&amp; uiValue==100) uiSetValue=0;

      

if uiSetValue != -1      //if changed then set the bar in motion.....
  {  
  if uiAniDraw  //animate motion of bar 
   {
    if curValue != -1   //init value check
     {curValueMove = uiSetValue - curValue;}
     else {curValue=uiSetValue;}   //on first set set don't animate....?
     uiValue=uiSetValue;
     uiSetValue=-1;  
   } else   //no animation
     {
     curValue=uiSetValue;
     uiValue=uiSetValue;
     uiSetValue=-1;
     curValueMove=0;
     }  
  }   
   
if curValue==-1 curValue=uiValue;   //initialize;

  
curPercent=curValue;

if curValueMove &gt; 0 
   {curPercent += min(curValueMove,uiAniSpeed);
    curValueMove -= uiAniSpeed;
    if curValueMove &lt;0 curValueMove=0;    
   }
else if curValueMove &lt;0 
   {curPercent -= min(abs(curValueMove),uiAniSpeed);
    curValueMove += uiAniSpeed;
    if curValueMove &gt;0 curValueMove=0;    
   }

curValue=curPercent;


barWidth:=round((curValue/100) * barw);



curColor=uiBarColor;
curColorBlend=uiBarColorBlend;


//draw_text_transformed(px+5,y,disptx,uiXscale,uiYscale,0);   




if uiBackSprite!=noone then
   {
       if uiSpriteScale==0  {
                             draw_sprite_stretched_ext(uiBackSprite,0,x,y,sprite_width,sprite_height,image_blend,uiAlpha);         
                            }  //stretch image to fit.
       else draw_sprite_stretched_ext(uiBackSprite,0,x,y,(sprite_get_width(uiBackSprite)*uiSpriteScale),(sprite_get_height(uiBackSprite)*uiSpriteScale),image_blend,uiAlpha);
   }  


if (uiBarSprite != noone) //drawing background sprite
   {
     cw=sprite_get_width(uiBarSprite);
     ch=sprite_get_height(uiBarSprite);
     
     draw_sprite_stretched_ext(uiBarSprite,0,barx,bary,cw,barh,c_gray,0.5);
     draw_sprite_stretched_ext(uiBarSprite,1,barx+cw,bary,barw-cw-cw,barh,c_gray,0.5);
     draw_sprite_stretched_ext(uiBarSprite,2,barx+barw-cw,bary,cw,barh,c_gray,0.5);     
   }


if (curValue&gt;0 ) &amp;&amp; (uiBarSprite=noone)
 {
   draw_roundrect_color_ext(barx, bary, barx+barWidth, bary+barh, uiRadiusX,uiRadiusY,curColor,curColor, false);   //fill
 }      
 
   
  
//uiSlideSprite = -1;  


//draw slide
if (uiSlideSprite==-1)  //no slidesprite; draw roundrect;
    {
    if (uiSliderWidth&lt;=0) sw=(barw div 3); else sw=uiSliderWidth;       
    sx=max(x,barx+barWidth-(sw div 2)); //set low pos
    sx=min(sx,barx+barw-sw); //set hi pos
    draw_roundrect_color_ext(sx, bary,sx+sw, bary+barh, uiRadiusX,uiRadiusY,uiSliderColor,uiSliderColor, false);   //fill     
    }
else  //draw slidesprite
    {    
    if (uiSpriteAlign)  //draw slidesprite within bar
     {
      sw=sprite_get_width(uiSlideSprite);
      sx=max(x+(sw div 2),barx+barWidth-(sw div 2)); 
  //    sx=min(sx,(barx+barw-(sw div 2)));
      draw_sprite(uiSlideSprite,0,sx+1,bary+(barh div 2)+1);
     } 
    else  //draw slidesprite to full bar
    {  
       sx=barx+barWidth; 
       draw_sprite(uiSlideSprite,0,sx,bary+(barh div 2));
    }   

    }
    
//draw text if any         
if (uiToggleOn &amp;&amp; string_length(uiOnLabel)&gt;0)//  draw yes....
 {
   draw_set_colour(uiOnLabelColor); 
   th=(barh-string_height(uiOnLabel)) div 2;
   draw_text(barx+5, bary+th+2, uiOnLabel);
 }
else if (uiToggleOn==false &amp;&amp; string_length(uiOffLabel)&gt;0)//  draw no....
 {
   draw_set_colour(uiOffLabelColor); 
   th=(barh-string_height(uiOffLabel)) div 2;
   draw_text(barx+barw-string_width(uiOffLabel)-5, bary+th+2, uiOffLabel);
 } 

  
draw_set_alpha(backalpha);  //restore alpha (in case of fadeout, etc    
  
  
  
  
  
    

       

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
